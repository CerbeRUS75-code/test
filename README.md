### GO
## ООП в Golang
 __"Как реализовано ООП в go?"__

__Ответ:__
 
 В go нет классической реализация ООП, так как он не объектно-ориентированный язык.

__"Как реализовано наследование?"__

__Ответ:__

Как такового наследования в go нет, но при этом у нас есть структуры - это специальные типы, в которые мы можем включать другие типы, в том числе такие же структуры. При этом методы дочерних структур родительская структура также будет наследовать.

__"Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?"__

__Ответ:__ 

"Реализация родительского метода будет переписана реализацией дочернего метода".
![image](https://github.com/user-attachments/assets/7b57598b-cbcb-4b68-92ca-f4a06298ec66)

__"Как реализована Инкапсуляция в go?"__
![image](https://github.com/user-attachments/assets/a0a2fcdf-cbfa-41e1-9a15-e05e192ac52d)

__"Как реализован полиморфизм в go?"__
![image](https://github.com/user-attachments/assets/760a22a1-c7bf-409e-b082-1ee78646d924)

## Области видимости в Golang

__"Что такое пакеты в go?"__

![image](https://github.com/user-attachments/assets/17b38eee-e519-4d5f-8426-88cac0716021)

__"Что такое глобальная переменная?"__

![image](https://github.com/user-attachments/assets/c02124eb-573f-4faf-8810-ff903a98497d)

__"Что такое фигурные скобки с не объявленным оператором в go функции?"__

![image](https://github.com/user-attachments/assets/de408c9f-ac2c-4618-8f1b-080b58c10631)

## Операторы в Golang

 __"В go есть оператор switch case, можно ли выполнить несколько условий в одном объявленном операторе?"__

![image](https://github.com/user-attachments/assets/1789587c-0738-467c-841d-ef4beb3981cd)

## Strings в Golang

__"Что представляют из себя строки в go?"__

![image](https://github.com/user-attachments/assets/7cd7137b-892b-4d4a-9b5f-e77d663f67d5)

__"Как можно оперировать строками?"__

![image](https://github.com/user-attachments/assets/59cffe1f-78c7-4a97-b943-ad4feb7c2fd1)

__"Что будет если сложить строки?"__

![image](https://github.com/user-attachments/assets/9ddf46cd-6cd1-4752-bf60-2b78ccf15c63)

__"Как определить количество символов для строки?" или "Какие есть нюансы при итерации по строке?"__

![image](https://github.com/user-attachments/assets/0c4588e8-0fb0-41a1-9875-2726b3c92fad)

## Int в Golang

__"Какие численные типы есть в go?"__

![image](https://github.com/user-attachments/assets/fbc7ec98-6f67-42c2-bfee-efe35238e3bb)

__"Чем отличается int от uint?"__

![image](https://github.com/user-attachments/assets/1dcf8376-d389-4907-be22-d6b6c1a6db48)

__"Что такое обычный int и какие есть нюансы его реализации?"__

![image](https://github.com/user-attachments/assets/315ac159-5b38-4f62-a8bc-cfadf115976e)

__"Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно?"__

![image](https://github.com/user-attachments/assets/bacc83f3-726b-49e2-a8f9-0783acc04111)

__"Сколько в памяти занимают реализации int32 и int64?"__

![image](https://github.com/user-attachments/assets/d9d67b42-124a-4024-bc42-6817982685e9)

__"Какой результат получим если разделить int на 0 и float на 0?"__

![image](https://github.com/user-attachments/assets/dc2cdc36-e86d-48f6-b52b-9699dd589f1b)

## Const в Golang

__"Что такое константы и можно ли их изменять?"__

![image](https://github.com/user-attachments/assets/0b100571-23f7-49a9-93ee-e1ee609daaa8)

__"Что такое iota?"__

![image](https://github.com/user-attachments/assets/db3c4935-b526-439d-bda9-a80b7dd25277)

## Array и slice в Golang

__"Что такое слайс и чем он отличается от массива?"__

![image](https://github.com/user-attachments/assets/6a26359a-2056-4a8f-9833-f23d8a2866cb)

__"Как работает базовая функция append для go?"__

![image](https://github.com/user-attachments/assets/5547a2c6-98e7-4f72-b40b-6b10019902a0)

__"Какой размер массива выделяется под слайс при его расширении за рамки его емкости?"__

![image](https://github.com/user-attachments/assets/8847fe0d-b2fb-4130-9693-f43f6f59353b)

__Сработает ли append в nil slice?__

Ответ: Да

__Сработает ли обращение по index в nil slice?__

Ответ: Нет, мы вышли за пределы допустимого

__Может ли длина слайса быть меньше длиной массива, на который он ссылкается?__

Ответ: Да, мы может из массива взять слайс, от того взять снова слайс, таким образом он будет меньше

## Map в Golang

__"Как реализована map(карта) go?"__

Хэш-таблица, контейнер данный ключ - значение, не отсортированный

Ключ проходит через хэш функцию, получается какое то значение хэша, свойства хэш функции: что на входе, дает на выходе точно такой же результат, иначе мы не получили бы значение, под капотом есть бакеты (ведра), у каждого есть емкость (8 пар ключ-значение), если по всем бакетам в среднем 6,5 занято, то начнется эвакуация

Коллизия (Collision). Так как хэш-функция не идеальна, передав в нее два разных значения мы можем получить один и тот же результат. В случае с бакетами нам нужно два разных значения положить в один и тот же бакет. Это называется коллизией. Для реализации hashmap необходимо иметь алгоритм их разрешения. Существует несколько таких алгоритмов (стратегий):

Closed addressing. Храним элементы с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, массив и др. Используется в следующих языках: Go, Java, Scala

![image](https://github.com/user-attachments/assets/d3a2ba0c-058c-4d8a-bfa5-949b02086571)

__"Почему нельзя брать ссылку на значение, хранящееся по ключу в map?"__

![image](https://github.com/user-attachments/assets/62a77b5a-d454-4daa-b6c4-d447d0ae09bf)

__"Что такое эвакуация, и в каком случае она будет происходить?"__

![image](https://github.com/user-attachments/assets/8c7436c9-ac03-458e-995e-08badccf294d)

__"Какие есть особенности синтаксиса получения и записи значений в map?"__

![image](https://github.com/user-attachments/assets/1077e4d9-ddb3-4256-9fe1-d4e818548ab6)

__"Как происходит поиск по ключу в map?__

![image](https://github.com/user-attachments/assets/605bdcda-4afd-4259-8ff3-7647bd7612f7)

## Интерфейсы в Golang

Ну по факту итерфейсом мы определяем поведение какой то сущности, например у нас есть структура, где мы говорим что у нас есть сущность, у которой есть какие то атрибуты, а интерфейс это уже про само действие, под этот интерфейс мы можем подогнать любое кол-во структур, таким образом жостигается полиморфизм, мы делаем так что бы некая структура реализовывала все методы из этого интерфейса, и тогда она реализует этот интерфейс, тогда она может быть использована

![image](https://github.com/user-attachments/assets/362df6ee-bf47-46ef-933d-92250dc93607)

__Какому интерфейсу может удовлетворять мапа как структура?__

Ответ: пустой интерфейс

__"Что такое пустой интерфейс?"__

![image](https://github.com/user-attachments/assets/cc134225-cebf-4d2b-9916-3210a6ccb5aa)

__"Что такое nil интерфейс?"__

![image](https://github.com/user-attachments/assets/07229d20-ad1c-483b-beba-5d1828444d4f)

__"Как преобразовать интерфейс к другому типу?"__

![image](https://github.com/user-attachments/assets/561967eb-333a-43c3-9a89-f3c5c425f6a8)

__"Как определить тип интерфейса?"__

![image](https://github.com/user-attachments/assets/d0e28bf2-4007-442e-a8e6-cb136203724e)

## Инструкция defer

__"Зачем используется ключевое слово defer в go?"__

![image](https://github.com/user-attachments/assets/7ae01b3d-3a42-441c-82cf-31dfd1936199)

__"Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции?"__

![image](https://github.com/user-attachments/assets/f65c1bf4-6572-49be-8944-0687dd199647)

__"Как передаются значения в функции, перед которыми указано ключевое слово defer?"__

![image](https://github.com/user-attachments/assets/0c9eb461-1ff7-4481-a1c9-582e44d5e284)


## Конкурентность в Golang

__Как утроен runtime в Go?__

Runtime в Go - это часть исполняющей системы, ответственная за управление памятью, планирование горутин и взаимодействие с операционной системой.

__"Что такое асинхронность?"__

![image](https://github.com/user-attachments/assets/82dbe120-8553-4bac-a356-238b56bf2b7c)

__"Что такое параллельность?"__

Параллельность: Это значит, что несколько задач исполняются в один и тот же момент времени, скорее всего используя при этом больше одного ядра ЦП.

![image](https://github.com/user-attachments/assets/62fa5be7-ad21-4436-bc4d-c1f2df502f88)

__"Что такое конкурентность?"__

Конкурентность: Это о том чтобы несколько задач исполнялись одновременно, но не обязательно в один и тот же момент времени.

![image](https://github.com/user-attachments/assets/f71bd3a9-d0d2-4115-b926-2c14c27344c3)

__"Что такое thread?"__

![image](https://github.com/user-attachments/assets/1f0a7ef6-47dc-4f75-b478-a125ba28bd5f)

__"Что такое goroutine?"__

![image](https://github.com/user-attachments/assets/eb5f11fd-dec1-4e76-a85b-5424d977618d)

__"Какие основные отличия горутины от thread?"__

![image](https://github.com/user-attachments/assets/a62f9d11-ff39-49fd-958d-b815034f0884)

__"Каков минимальный и максимальный вес горутин?"__

![image](https://github.com/user-attachments/assets/147dbfc0-9e39-4995-834e-30e51762047a)

__"Что будет если размер горутины превысил допустимый максимум?"__

![image](https://github.com/user-attachments/assets/6a1b0b78-8f0b-432a-afac-cd66736093e1)

__"Какое максимальное количество горутин может быть запущено в системе?"__

![image](https://github.com/user-attachments/assets/a20047bb-e50b-4e87-ac22-163f4bea0610)

__"Что такое планировщик go?"__

GMP модель G - горутина, M - машина (но по сути это поток операционной системы), P - процессор (по факту это структура внутри run time), здесь процесс распределяет горутины по потокам, у каждой машины есть своя локальная очередь и в нее попадают горутины и по очереди выполняются, так же есть глобальная очередь, есть отдельное место где горутины синхронные и асинхронные siscallы делают, если синхронные, это напрмер запись на диск, чтение, это долго и асинхронно мы это делать не можем, поэтому поток с этой горутиной открепляем (hand off), асинхронные обично по сети, net poller. Так это всё и живет, у нас есть несколько очередей, локальные очереди реализованы через log free, примитивы синхронизации, глобальные очереди через Mutex. Допустим если поток обработал все горутины, попробует забрать часть нагрузки у другого потока, если там пусто,  он пойдет в глобальную очередь, сходит в сисколы (синхронные, асинхронные), так происходит что бы один поток не тротился, а другой простаивал, что бы более менее распределенная нагрузка была


![image](https://github.com/user-attachments/assets/6d50e983-1474-4ed4-a15d-16306c87da1f)

__"В равной ли степени горутины делят между собой процессорное время?"__

![image](https://github.com/user-attachments/assets/5446a221-8ab6-4db3-8bde-c36a7d7ece9d)

__"Какие есть способы остановить все горутины в приложении?"__

![image](https://github.com/user-attachments/assets/088e9fad-3faf-47b9-bd51-75b031fd625c)

__"Как вручную задать количество процессоров P для приложения?"__

![image](https://github.com/user-attachments/assets/70be96ad-54a2-48bd-ac20-9aabc800f086)

__"Как принудительно переключить контекст?"__

![image](https://github.com/user-attachments/assets/165cf25c-d8d1-4bc8-89f9-a08c124309d2)

__"Как наладить связь между горутинами?"__

![image](https://github.com/user-attachments/assets/064d6dd4-db82-4d00-bde9-9be1068d685e)

__"Какие есть примитивы синхронизации?"__

Примитивы синхронизации в Go включают в себя каналы, мьютексы (Mutex), условные переменные и атомарные операции.


![image](https://github.com/user-attachments/assets/d483c6bd-4810-49a5-a57f-b92b03efc2d6)

__"Что такое wait group?"__

WaitGroup из пакета sync в Go представляет собой счетчик, который используется для ожидания завершения определенного количества горутин. Например, если у нас есть несколько горутин, которые выполняются параллельно, и нам необходимо дождаться их завершения, мы можем использовать WaitGroup, чтобы синхронизировать их выполнение. Методы Add, Done и Wait позволяют управлять счетчиком: Add увеличивает счетчик, Done уменьшает его при завершении каждой горутины, а Wait блокирует выполнение до тех пор, пока счетчик не станет равным нулю.


![image](https://github.com/user-attachments/assets/416dce45-3499-48f1-98c4-4cf36792fc7b)

__"Для чего используются mutex и какие бывают?"__

![image](https://github.com/user-attachments/assets/22cb6016-e280-4f15-afcb-5ff30c272b8f)

__"Для чего используется atomic?"__

![image](https://github.com/user-attachments/assets/278385c4-ea8a-4885-a23e-9b61be5ff75e)

__"Для чего используется sync map?"__

![image](https://github.com/user-attachments/assets/4d706cfb-dde3-4cdc-a05f-7b4d122d9a2e)

__"Что такое graceful shutdown?"__

![image](https://github.com/user-attachments/assets/cca07006-bcbc-4cfe-a69f-4bf0128564e8)

## Каналы в Golang

__"Что такое channel?"__

![image](https://github.com/user-attachments/assets/d01d1879-9de5-4611-8ddb-46261fbf7b00)

__"Что такое буферизированный и небуферизированный channel?"__

![image](https://github.com/user-attachments/assets/287acea4-ee3d-4f1e-ab38-aeb7967191e6)

__"Какие действия можно произвести с каналом?"__

![image](https://github.com/user-attachments/assets/ba20388f-537b-4f53-97ca-1e7e7f02d59a)

__"Что будет если писать/читать в nil channel?"__

![image](https://github.com/user-attachments/assets/c9b6fab0-6cfa-4349-b7ed-c50c8ebb66e4)

__"Что будет если писать/читать в/из закрытый channel?"__

![image](https://github.com/user-attachments/assets/752a283f-60c9-4c41-aefb-a481b39ad476)

__"Что будет если писать/читать в/из буферизированный channel?"__

![image](https://github.com/user-attachments/assets/d438ff7e-93a2-4722-9590-527f8b2cd124)
![image](https://github.com/user-attachments/assets/1d461cf4-ff11-4b3c-afe0-e320bde0c61f)

__"Что будет если писать/читать в/из небуферизированный channel?"__

![image](https://github.com/user-attachments/assets/dfecb2fa-b655-49d0-938e-7e6f829d9ba9)

__"Как закрыть channel? Что с ним происходит?"__

![image](https://github.com/user-attachments/assets/099ac79d-e095-449a-a6a4-d8f973263c63)

__"Какие есть инструкции для чтения из channel?"__

![image](https://github.com/user-attachments/assets/05e9d08f-1d1d-48d7-b6b8-ef5862b6cdb8)
![image](https://github.com/user-attachments/assets/0fec597b-560b-4f1e-9018-082e78c27113)
![image](https://github.com/user-attachments/assets/6c04ff1e-251c-4ca1-ac44-46a444d60b6f)

__"Как сделать select неблокирующим?"__

![image](https://github.com/user-attachments/assets/075f7b13-e2bb-40c5-a8f1-c03b98baa46b)

__"Какой порядок исполнения операций case в select?"__

![image](https://github.com/user-attachments/assets/686c551d-a5d1-400a-80e4-ee912c3f2dd5)

## Контексты в Golang

__"Что такое context?"__

![image](https://github.com/user-attachments/assets/3a5a745d-ff31-423b-8807-e52bf97ace02)

__"Для чего применяется context?"__

![image](https://github.com/user-attachments/assets/d64a5436-3272-45da-a91e-426d923d5f7a)

__"Чем отличается context.Background от context.TODO?"__

![image](https://github.com/user-attachments/assets/6340d0e1-e51a-4f72-aec6-778a643ec87e)

__"Как передавать значения и вычитывать их из context?"__

![image](https://github.com/user-attachments/assets/b546529d-3a0c-46e3-bdce-62870236b001)

__"Каковы отличия context.WithCancel, context.WithDeadline, context.WithTimeout?"__

![image](https://github.com/user-attachments/assets/af6f81ed-57ef-4d4c-ba86-1cb230f97785)

__"Как обрабатывать отмену context?"__

![image](https://github.com/user-attachments/assets/ee424027-56af-44cc-b396-1ea064db4900)

## Память в Golang

__"Как реализовано хранилище памяти в Go?"__

![image](https://github.com/user-attachments/assets/5cac674b-b4dd-4302-995b-4f960a14107b)

__"Что обозначает * и &?"__

![image](https://github.com/user-attachments/assets/d7fda13b-7048-4f61-bded-f1f4f0a8e1fd)

__"Как происходит передача параметров в функцию?"__

![image](https://github.com/user-attachments/assets/81a234c1-ad40-477c-a430-afcba29c357b)
![image](https://github.com/user-attachments/assets/5cc16ea2-0ccb-4efd-901b-31c3da167954)

__"Есть ли особенности поведения при передаче map и slice в функцию?"__

![image](https://github.com/user-attachments/assets/fcec56be-68d4-433e-81c6-bd6c20efb34b)
![image](https://github.com/user-attachments/assets/87e7e6f2-a01f-411d-8648-fe46087664c4)

__"Как функции делятся памятью?"__

![image](https://github.com/user-attachments/assets/42af0908-d53d-479d-8271-eab5fb941f91)

__"Можно ли явно аллоцировать переменную в стэке или куче?"__

![image](https://github.com/user-attachments/assets/b2649ad8-5d64-45c1-a404-c17bb72819ab)

## Сборщик мусора в Golang

__"Что такое сборщик мусора и по какому алгоритму он реализован в Go?"__

__Какой алгоритм у сборщика мусора?__

В целом, алгоритм можно представить циклом из нескольких шагов:

Покрасить все корневые объекты (стек и глобальные переменные) в серый.

Выбрать серый объект из набора серых объектов и пометить его как чёрный.

Все объекты, на которые указывает чёрный объект, пометить серым. Это гарантирует, что сам объект и объекты, на которые он ссылается, не будут выброшены в мусор.

Если в графе остались серые объекты, вернуться к шагу 2.

![image](https://github.com/user-attachments/assets/505128b6-3b0b-4cbe-88f6-affe571ddf2b)

__"Расскажите про алгоритм mark and sweep"__

![image](https://github.com/user-attachments/assets/3f82b6d5-1f03-4369-80a6-0294efb65915)
![image](https://github.com/user-attachments/assets/c58b53dd-34d9-4135-a9b5-8b41d3f94a05)

__"Когда запускается сборщик мусора?"__

![image](https://github.com/user-attachments/assets/e0d80d5a-a6d3-40a4-a76e-2a6b653636a4)

__"Каковы ресурсы, которые потребляет сборщик мусора?"__

![image](https://github.com/user-attachments/assets/7989482d-65d1-4dc3-af40-10d61a1b389f)

## архитектура

__SOLID__

S - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.

O - Open closed Principle - принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения.

L - Liskov substitution Principle - принцип подстановки Барбары Лисков. Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.

I -  Interface Segregation Principle - принцип разделения интерфейсов. Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

D - Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

## алгоритмы

__Какие есть алгоритмы балансировки?__

Алгоритмы балансировки нагрузки необходимы для равномерного распределения запросов между серверами в кластере, чтобы предотвратить перегрузку одного сервера и обеспечить более эффективное использование всех ресурсов. Некоторые из основных алгоритмов балансировки нагрузки включают:
1. Round Robin (круговой выбор): При использовании данного алгоритма запросы поочередно отправляются на каждый сервер в порядке их добавления в пул серверов. Этот метод прост в реализации, но не учитывает разную загруженность серверов.
2. Least Connections (с наименьшим количеством соединений): Запросы направляются на сервер с наименьшим количеством активных соединений. Этот метод эффективен, когда нагрузка на серверы сильно различается.
3. IP Hashing (хеширование IP-адресов): Для каждого запроса вычисляется хеш от IP-адреса клиента, и на основе этого хеша определяется сервер, на который будет направлен запрос. Этот алгоритм позволяет "привязать" определенного клиента к одному серверу.
4. Random (случайный выбор): Запросы случайным образом направляются на один из серверов из пула. Хотя этот метод прост в реализации, он не гарантирует равномерного распределения нагрузки

__Чистая аритектура__

![image](https://github.com/user-attachments/assets/7a65bd9e-af31-464d-bdd5-ccc7cf9e4557)


## Серверные вопросы

__Чем отличается unary от stream__?

Unary - это протокол взаимодействия клиент-сервер, где каждый запрос серверу соответствует одному ответу. Stream - это протокол, где возможно отправление нескольких запросов и получение нескольких ответов в рамках одного потока.


### Базы данных

## Репликация

__Что такое репликация и какие проблемы она решает?__

Ну допустим какие проблемы решает репликация, допустим у нас есть веб приложение, туда приходит на чтение много запросов на чтение и запись, таким образом мы очень нагружаем систему, поэтому для снижения нагрузки на диск, можем добавить репликацию. Второе это мы можем надежность увеличить, мы будет переносить данные, в случае отказа мастера, мы просто делаем фолловер на реплику, реплика становится мастером соответственно.

__Какие есть типы репликации?__

Синхронна и асинхронная репликация, довольно всё просто, синхронная реаликация - мы пока что не закомитим транзакцию на реплики, не закомитим ее на мастере, таким образом мы достигаем полной согласованности данных.
Асинхронная не так, мы закомитили на мастере, сказали всё класс, а реалика потом уже сама доходит по алгоритмам и комитит их

__Что если упал мастер?__

Обычно это делает автоматическая система, ПГконсул от Яндекса, если нет, то придется руками залезать в конфигурацию и делать пгпромоут реплики что бы она становилась мастером. Например алгоритм RAFt, у него там прикольная схема, что у нас есть не четное кол во узлов, идет какой то выбор, происходит пинг с какой то отсечкой, кто то через 3 сек, кто то через 4 ответил, и кто первый отправит всем хостам в рафте, тот и станет мастером

__Что такоее шардирование?__

Ну, миы ограничены в масштабировании бдшки, рано или поздно у нас закончится место на диске, а если у нас там какой нибудь хайлоад, нам хотелось бы разнести, репликация нам в этом случае не подходит, потому что мы ровно так же копируем данные на другие сервера, а нам хотелось бы хранить кусочками. Я знаю что из коробки так работает в кассандре, в монго дб, в простгрессе и MySQL такого из коробки нету, приодится какие то свои решения писать

__В чем разница между шардированием и партиционированием?__

Шардирование (sharding) используется для распределения данных по нескольким независимым серверам для улучшения производительности и масштабируемости, тогда как партиционирование (partitioning) разделяет данные на более мелкие части в пределах одного сервера для упрощения управления и повышения эффективности.

![image](https://github.com/user-attachments/assets/ec900db4-94f0-4815-a55c-0649b3aa4faa)

__Виды партиционирования__

(желательность выполнять партиционирование так, что бы данные равномерно распределялись по партициям, как пример это делает хэш вид)

![image](https://github.com/user-attachments/assets/42554e42-df56-4231-8b54-a01c31bf6f64)

__Когда использовать партиционирование?__

Ну можем обеспечить 90% запросов с фильтром по ключу партиционирование, что должно увеличить скорость, так же круто использовать для ренджа по датам, к ним доступ по периодам быстрее будет выполняться, если данных мало, то используем диапазо по месяцам, если много то разбиение по дням, еще если старые штуки надо заархивировать, счета за 2000 год условно, можем их просто отрезать и запушить в партицию

__Консистентное хэширование__

Когда хэш берем от какого то ключа, его распологаем на абстрактной окружности с нодами, ближайшая нода (по часовой стрелке), это та надо, куда мы его кладем

__Какую проблему решает консинстентное хэширование?__

Скорее проблему решардига, когда добавляем новый шард, нужно перекинуть некоторые данные, и консинстентное хэширование это минимизирует, т е это кол во данных, которые нужно перекинуть.

__Какие типы баз данных существуют?__

По профилю нагрузки есть ОЭЛТИПИ и ОЛАБ базы данный, ОЭЛТИПИ это транзакционные, к ним можно отнести например Postgress, это когда у тебя маленькие запросики selectiki конкретных строчек, они быстрые и расчитаны на такую нагрузку. ОЛАБ базы данных, аналитические, такие как ClickHouse, которые уже по столбцам, ну и они отличаются методом хранения данных, есть строковое хранение данных, есть колоночное, у нас байтики, ну значение колонок хранятся рядом друг с другом, поэтмоу чтение из колонок достаточно быстрое. Есть так же документоориентированные базы данных (MongoDB), реляционные, ключ - значение (Reddis)  


## Прочее

__Специфичные типы данных в постгре__

![image](https://github.com/user-attachments/assets/0f9e4ff3-a54c-4014-a8dc-b3d249d99c62)


![image](https://github.com/user-attachments/assets/b79f31a6-7619-424f-ad34-7c383eb18e38)

__Индексы__





### Управление релизами

![image](https://github.com/user-attachments/assets/56ede736-5f24-4e3c-a63f-da3bf3660c81)




### k8s

## плюсы

1. Прогнозиремое поведение: Все аспекты взаимодействия с приложением контролируемы, не нужно ходить к админу и ждать по пол дня, мы сами можем это делать, самостоятельно можем настроить конфигурацию приложения, так же кубик безопасно хранит токены и пароли, внутреннее взаимодействие и внешнее сетевое взаимодействие, опять же не придется писать админу и говорить что бы он ендпоинт прописал на nginx где нибудь, всё сами можем. Можем определить сколько наше приложение ест CPU и RAM, настроить хелсчеки, так же декларативность присутствует (пишем ЧТО мы хотим получить на выходе, а не как k8s должен это делать).
2. Time-to-market и польза бизнесу. Не нужно постоянно ждать админа, ускоряет разработку.
3. селфхиллинг - кубик будет поддерживать наше приложение, поднимать его если оно упало автоматически, это мы можем отслеживать, поэтому если в офис придет доставщик пиццы и в консоле пропишет kubectl delete POD, репликасет создаст его снова

# Минимальная единица кубика - под (POD)


### Kafka

__Что такое кафка?__

![image](https://github.com/user-attachments/assets/7e4b904d-dacc-433c-99aa-fc67b1784952)

__Гарантия отказоустойчивости__

Ну вообще кафка в теории может терять сообщения, потому что CAP теорима и система отказоустойчивости не могут быть консистентными. В кафке есть настройки, которые могут снизить вероятность этой проблемы до каких то приемлимых значений. 
1. мин ин синк реплика - при записи данных в кафку, мастер нода прежде чем подтвердить что данные успешно записались, он подождет, пока данные дойдут до реплики
2. анклин лидер элекшион - говорит о том, что мы можем выбрать в качестве лидера только ту ноду, на которой данные находятся в актуальном состоянии
































































